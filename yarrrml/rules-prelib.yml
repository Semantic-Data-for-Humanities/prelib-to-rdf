prefixes:
 # La validité de ces prefixes ainsi que les URI des propriétés et classes utilisées restent à vérifier
 # Par exemple, crm:P98i_was_born ou crm:P98_was_born ?
 # Référence à compulser : les namespaces de OntoMe (https://ontome.net/namespace)
 bibo: http://purl.org/ontology/bibo/
 bnf-onto: http://data.bnf.fr/ontology/bnf-onto/
 crm: http://www.cidoc-crm.org/cidoc-crm/
 crmba: https://ontome.net/ns/crmba/
 crm-sup: https://ontome.net/ns/sdh-crm-supplement/
 databnf: http://data.bnf.fr/ark:/
 foaf: http://xmlns.com/foaf/0.1/
 frbroo: http://iflastandards.info/ns/fr/frbr/frbroo/
 grel: http://users.ugent.be/~bjdmeest/function/grel.ttl# 
 idlab-fn: http://example.com/idlab/function/
 idref: https://www.idref.fr/
 factgrid: https://database.factgrid.de/entity/
 isni-onto: http://isni.org/ontology#
 isni: http://isni.org/isni/
 lexvo: http://lexvo.org/id/iso639-3/
 owl: http://www.w3.org/2002/07/owl#
 prelib: http://mshb.huma-num.fr/prelib/
 sdh: https://ontome.net/ns/sdhss/
 sdh-int: https://ontome.net/ns/intellectual-literary-life/
 sdh-sls: https://ontome.net/ns/social-life-specific/
 sdh-so: https://ontome.net/ns/social-legal-economic-life/
 sudoc: http://www.sudoc.fr/
 viaf: http://viaf.org/viaf/
 wd: http://www.wikidata.org/entity/
 worldcat: http://www.worldcat.org/oclc/
 xsd: http://www.w3.org/2001/XMLSchema#

variables:
  access: &dbHost http://localhost/django_mshb
  type: &dbType mysql
  referenceFormulation: &csvReferenceFormulation csv
  credentials: &credentials
    username: $(_username)
    password: $(_password)

sources:
 prelib_airegeographique:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : SELECT * FROM prelib_airegeographique; 
 prelib_appellationpersonne:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : > 
   SELECT * FROM prelib_appellationpersonne 
   JOIN prelib_langue ON prelib_langue.id = prelib_appellationpersonne.langue_id; 
 prelib_appellationcollectif:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : >
   SELECT * FROM prelib_appellationcollectif 
   JOIN prelib_langue ON prelib_langue.id = prelib_appellationcollectif.langue_id;
 prelib_batiment:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : SELECT * FROM prelib_batiment;
 prelib_collectif:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : > 
   SELECT prelib_collectif.*, 
   SUBSTRING(ark_bnf, 9, CHAR_LENGTH(ark_bnf) - 8) AS FRBNF,
   REPLACE(isni, ' ', '') AS ISNI_SPACELESS
   FROM prelib_collectif;
 prelib_collectifecritoeuvre:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query: >
   SELECT (CASE WHEN date_ecriture REGEXP '^\\d+$' THEN date_ecriture END) AS annee, 
   prelib_collectifecritoeuvre.*, prelib_fonctionecritoeuvre.nom AS nom_fonction, 
   prelib_fonctionecritoeuvre.code_idref AS code_idref_fonction
   FROM prelib_collectifecritoeuvre 
   JOIN prelib_fonctionecritoeuvre ON prelib_fonctionecritoeuvre.id = prelib_collectifecritoeuvre.fonction_id  
   ORDER BY prelib_collectifecritoeuvre.id
 prelib_ecritoeuvre:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  # date_ecriture est de type VARCHAR et contient parfois des années, parfois des intervales d'années, parfois des dates au format français
  # parfois des commentaires. Pour l'instant, on se contente de récupérer les saisies conformes à la la REGEXP '^\\d+$'. 
  # Puisque prelib_ecritoeuvre contient des relations avec d'autres roles que les auteurs, date_ecriture devrait être considéré 
  # comme la date d'exercice du rôle et non pas la date d'écriture à proprement parler.
  # A FAiRE : Voir s'il ne faudrait tout simplement pas retirer cette information des triplets.
  # Creation des champs suivants :
  # - annee
  query: >
   SELECT (CASE WHEN date_ecriture REGEXP '^\\d+$' THEN date_ecriture END) AS annee, 
   prelib_ecritoeuvre.*, prelib_fonctionecritoeuvre.nom AS nom_fonction, 
   prelib_fonctionecritoeuvre.code_idref AS code_idref_fonction
   FROM prelib_ecritoeuvre
   JOIN prelib_fonctionecritoeuvre ON prelib_fonctionecritoeuvre.id = prelib_ecritoeuvre.fonction_id  
   ORDER BY prelib_ecritoeuvre.id
 prelib_editeoeuvre:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_editeoeuvre;
 prelib_editerevue:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_editerevue;  
 prelib_edition:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT prelib_edition.*, SUBSTRING(ark_bnf, 9, CHAR_LENGTH(ark_bnf) - 8) AS FRBNF FROM prelib_edition;
 prelib_estdedicacea:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_estdedicacea;
 prelib_estdedicaceacollectif:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_estdedicaceacollectif;
 prelib_etudes:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_etudes;
 prelib_oeuvre:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT prelib_oeuvre.*, SUBSTRING(ark_bnf, 9, CHAR_LENGTH(ark_bnf) - 8) AS FRBNF FROM prelib_oeuvre;
 prelib_oeuvreedition:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : SELECT * FROM prelib_oeuvreedition;  
 prelib_oeuvrelangue:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : > 
   SELECT * FROM prelib_oeuvrelangue JOIN prelib_langue 
   WHERE prelib_langue.id = prelib_oeuvrelangue.langue_id;
 prelib_oeuvre_types:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : SELECT * FROM prelib_oeuvre_types;
 prelib_paraitdans:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : >
   SELECT (CASE WHEN (jour_parution IS NOT NULL AND mois_parution IS NOT NULL AND annee_parution IS NOT NULL) 
   THEN CONCAT_WS('-', LPAD(`annee_parution`, 4, 0), LPAD(`mois_parution`, 2, 0), LPAD(`jour_parution`, 2, 0)) 
   WHEN (annee_parution IS NOT NULL) THEN annee_parution END) AS date_parution, 
   (CASE WHEN (jour_parution IS NOT NULL AND mois_parution IS NOT NULL AND annee_parution IS NOT NULL) 
   THEN 'date' WHEN (annee_parution IS NOT NULL) THEN 'gYear' END) AS date_parution_dtype,
   prelib_paraitdans.*
   FROM prelib_paraitdans;
 prelib_personne:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  # Creation des champs suivants :
  # - date_naissance = date de naissance complète yyyy-mm-dd ou yyyy
  # - date_naissance_dtype = date ou gYear
  # - idem pour date_deces et date_deces_dtype
  # - FRBNF = numéro de notice BnF, utilisé systématiquement à la place de ark_bnf car RML Mapper encode les URI (par ex. / devient %2F).
  # - gender = Male ou Female
  query: >
   SELECT (CASE WHEN (jour_naissance IS NOT NULL AND mois_naissance IS NOT NULL AND annee_naissance IS NOT NULL) 
   THEN CONCAT_WS('-', LPAD(`annee_naissance`, 4, 0), LPAD(`mois_naissance`, 2, 0), LPAD(`jour_naissance`, 2, 0)) 
   WHEN (annee_naissance IS NOT NULL) THEN annee_naissance END) AS date_naissance, 
   (CASE WHEN (jour_naissance IS NOT NULL AND mois_naissance IS NOT NULL AND annee_naissance IS NOT NULL) 
   THEN 'date' WHEN (annee_naissance IS NOT NULL) THEN 'gYear' END) AS date_naissance_dtype, 
   (CASE WHEN (jour_deces IS NOT NULL AND mois_deces IS NOT NULL AND annee_deces IS NOT NULL) 
   THEN CONCAT_WS('-', LPAD(`annee_deces`, 4, 0), LPAD(`mois_deces`, 2, 0), LPAD(`jour_deces`, 2, 0)) 
   WHEN (annee_deces IS NOT NULL) THEN annee_deces END) AS date_deces, 
   (CASE WHEN (jour_deces IS NOT NULL AND mois_deces IS NOT NULL AND annee_deces IS NOT NULL) 
   THEN 'date' WHEN (annee_deces IS NOT NULL) THEN 'gYear' END) AS date_deces_dtype,   
   SUBSTRING(ark_bnf, 9, CHAR_LENGTH(ark_bnf) - 8) AS FRBNF,
   REPLACE(isni, ' ', '') AS ISNI_SPACELESS, 
   IF(sexe = 'M', REPLACE(sexe, 'M', 'male'),IF(sexe = 'F', REPLACE(sexe, 'F', 'female'),'')) AS gender, 
   prelib_personne.* FROM prelib_personne ORDER BY id ;
 prelib_profession:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_profession WHERE qualite_id IS NOT null;
 prelib_qualiteparticipecollectif:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_qualiteparticipecollectif;
 prelib_qualiterelation:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_qualiterelation;
 prelib_relationinterpersonnelle:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query: >
   SELECT (CASE WHEN (jour_debut_relation IS NOT NULL AND mois_debut_relation IS NOT NULL AND annee_debut_relation IS NOT NULL) 
   THEN CONCAT_WS('-', LPAD(`annee_debut_relation`, 4, 0), LPAD(`mois_debut_relation`, 2, 0), LPAD(`jour_debut_relation`, 2, 0)) END) AS date_debut_relation, 
   (CASE WHEN (jour_fin_relation IS NOT NULL AND mois_fin_relation IS NOT NULL AND annee_fin_relation IS NOT NULL) 
   THEN CONCAT_WS('-', LPAD(`annee_fin_relation`, 4, 0), LPAD(`mois_fin_relation`, 2, 0), LPAD(`jour_fin_relation`, 2, 0)) END) AS date_fin_relation, 
   prelib_relationinterpersonnelle.* FROM prelib_relationinterpersonnelle ORDER BY id ;
  #  Version de la requête qui crée nécessite de tester dans le mapping le type de date pour éviter de créer des littéraux égaux 
  #  chaînes de caractères vides.
  #  SELECT (CASE WHEN (jour_debut_relation IS NOT NULL AND mois_debut_relation IS NOT NULL AND annee_debut_relation IS NOT NULL) 
  #  THEN CONCAT_WS('-', LPAD(`annee_debut_relation`, 4, 0), LPAD(`mois_debut_relation`, 2, 0), LPAD(`jour_debut_relation`, 2, 0)) 
  #  WHEN (annee_debut_relation IS NOT NULL) THEN annee_debut_relation END) AS date_debut_relation, 
  #  (CASE WHEN (jour_debut_relation IS NOT NULL AND mois_debut_relation IS NOT NULL AND annee_debut_relation IS NOT NULL) 
  #  THEN 'date' WHEN (annee_debut_relation IS NOT NULL) THEN 'gYear' END) AS date_debut_relation_dtype, 
  #  (CASE WHEN (jour_fin_relation IS NOT NULL AND mois_fin_relation IS NOT NULL AND annee_fin_relation IS NOT NULL) 
  #  THEN CONCAT_WS('-', LPAD(`annee_fin_relation`, 4, 0), LPAD(`mois_fin_relation`, 2, 0), LPAD(`jour_fin_relation`, 2, 0)) 
  #  WHEN (annee_fin_relation IS NOT NULL) THEN annee_fin_relation END) AS date_fin_relation, 
  #  (CASE WHEN (jour_fin_relation IS NOT NULL AND mois_fin_relation IS NOT NULL AND annee_fin_relation IS NOT NULL) 
  #  THEN 'date' WHEN (annee_fin_relation IS NOT NULL) THEN 'gYear' END) AS date_fin_relation_dtype,
  #  prelib_relationinterpersonnelle.* FROM prelib_relationinterpersonnelle ORDER BY id ;  
 prelib_revue:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT prelib_revue.*, SUBSTRING(ark_bnf, 9, CHAR_LENGTH(ark_bnf) - 8) AS FRBNF FROM prelib_revue;
 prelib_typeoeuvre:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation   
  query : SELECT * FROM prelib_typeoeuvre;
 prelib_typecollectif:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_typecollectif;
 prelib_ville:
  access: *dbHost
  credentials: *credentials
  type: *dbType
  referenceFormulation: *csvReferenceFormulation
  query : SELECT * FROM prelib_ville;

# A FAIRE : 
# - Mettre les triplets dans des graphes, générer des N-Quads
# - Modifier PRELIB pour ajouter les identifiants Geonames des villes
# - Editer PRELIB pour verser le champ 'intitule' de prelib_profession dans qualite_id (prelib_qualiteparticipecollectif) 
#    (Fait en grande partie le 10 mai 2022, manque une vingtaine de "professions" à traiter)
# - Exprimer les informations de prelib_ecritoeuvre avec les ontologies utilisées par la BnF et l'Abes

# Ne faudrait-il pas distinguer la notice PRELIB de ce dont parle la notice comme le fait IdRef 
# et la BnF ? ex. sur data.bnf.fr : DESCRIBE <http://data.bnf.fr/ark:/12148/cb16623239r#about>
# qui comprend le triplet :
# <http://data.bnf.fr/ark:/12148/cb16623239r> <http://xmlns.com/foaf/0.1/focus> <http://data.bnf.fr/ark:/12148/cb16623239r#about>

# Au sujet des blank nodes :
# - https://github.com/RMLio/yarrrml-parser/issues/67#issuecomment-614669254
# - https://rml.io/yarrrml/spec/#referring-to-other-mappings

# Remarques :
# - Le mapping proposé par Data4Humanities ne se préoccupe pas les URI des ressources correspondant
#    aux concepts de PRELIB (personnes, collectifs, etc.). Or certaines ressources
#    instances de la même classe (ex. sdh-so:C7 "Occupation" ou frbroo:F24 "Publication Expression") 
#    proviennent de plusieurs tables (trois dans le cas des Occupations). 
#    Il n'y a dans ce cas pas d'autre solution que de créer des ressources anonymes 
#    (pas de possibilité de créer des ressources d'URI de type https://mshb.huma-num.fr/prelib/occupation/562/, 
#    par exemple car le chiffre final correspond à la clé primaire de ces trois tables).
#    Il faudrait définir dès le départ si les ressources doivent/peuvent être anonymes ou non 
#    et pour les ressources anonymes, définir le schéma de leur URI.
# - Autrement dit, on ne peut pas comme l'a fait Data4Humanities proposer pour chaque table une 
#    la classe d'une ontologie car la même table peut servir plusieurs fois dans les mappings.
#    Par exemple l'alignement proposé pour la table prelib_edition est la classe frbroo:F3 Manifestation Product Type et 
#    celui de la table prelib_editeoeuvre est frbroo:C1 Expression Publication Event, or les instances de cette dernière
#    classes ont été créées par un mapping sur prelib_edition.
# - La modélisation en RDF ne peut se faire à partir d'une liste de tables mais à partir du schéma de 
#    la base de données et du représentation graphique du graphe RDF attendu. Dans PRELIB, par exemple, 
#    cela n'a pas de sens de tenter de modéliser séparément prelib_ecritoeuvre, 
#    prelib_collectifecritoeuvre (qui sont équivalentes) et prelib_fonctionecritoeuvre (qui sert à stocker les 
#    fonctions des contributeurs à des oeuvres et est réféencée par les deux autres).
# - Le mapping des tables de jonction (relations n-n) pose question. Par ex., le choix a été fait  
#    d'instancier les frbroo:F28 "Expression Creation" en partant de la table prelib_ecritoeuvre 
#    et créant des ressources anonymes. Or la table prelib_ecritoeuvre contient les relations entre
#    une oeuvre et une personne à travers une fonction. Uderzo par exemple apparaitra deux fois dans 
#    la table prelib_ecritoeuvre pour sa relation à "Le Grand Fossé", une fois en tant que scénariste 
#    et une autre fois en tant que dessinateur. L'instanciation des frbroo:F28 "Expression Creation" 
#    en partant de la table prelib_ecritoeuvre par donc du principe que la création de l'expression
#    est la combinaison d'une personne et d'une fonction. Mais cela correspond-il à la vision des 
#    auteurs de l'ontologie FRBROO ? Remarquons au passage que l'on aurait probalement pu pousser la 
#    modélisation en distinguant l'expression des dessins et l'expression du texte du scénrario.
#    
#    Par contre, partir de la table prelib_editeoeuvre pour instancier les sdh-int:C1 Expression Publication Event
#    suppose donc qu'il y a autant de "expression publication event" que de co-éditeurs. Ce n'est peut-être pas
#    correct d'un point de vue sémantique. Cela demande un peu de gymnastique intellectuelle mais créer 
#    les triplets liés aux éditions en passant par la table prelib_editeoeuvre a nécessité trois mappings : 
#    - ManifestationProductTypeMapping qui boucle sur prelib_edition et crée des prelib:edition de 
#       classe frbroo:F3, 
#    - ExpressionPublicationEventMapping qui boucle sur prelib_edition et des prelib:edition-event de 
#       classe sdh-int:C1 (remarquez que cette ressource n'est pas anonyme)
#    - EditeOeuvreMapping qui boucle sur la fameuse table prelib_editeoeuvre et qui crée des triplets 
#       permettant de lier les ressources prelib:edition-event de classe sdh-int:C1 avec les éditions
#       et leurs éditeurs
# - Méthodologie retrospective pour écrire EditeOeuvreMapping :
#    1. la source : la table sur laquelle on boucle et dont les lignes sont les sujets des prédicats du mapping
#    2. subjects : optionnel (auquel cas ont écrit des triplets qui ont pour sujet des ressources anonymes)
#     se demander quelle est la colonne de la table qui sert à construire l'URI des sujets
#    3. predicatesobjects : dans le cas où l'objet est une URI, se demander dans quel mapping se trouvent-elles
#     Au départ, j'étais aller chercher les éditions et les collectifs dans ExpressionPublicationEventMapping
# - RML mapper ne crée pas les triplets dont l'objet est une URI et a pour valeur NULL dans la base de données. Mais il ne tient 
#    pas compte du fait qu'un littéral a pour valeur un VARCHAR dont la valeur est une chaine vide ou NULL (c.f. ISNI_SPACELESS). 
#    Il existe donc des triplets dont l'objet est un littéral vide :
#      <http://mshb.huma-num.fr/prelib/edition/1> <http://purl.org/ontology/bibo/isbn13> "".

mappings:
# Inspiré de data.bnf.fr : DESCRIBE <http://data.bnf.fr/ark:/12148/cb16623239r#about>
# Voir aussi Théodore Hersart de la Villemarqué http://data.bnf.fr/ark:/12148/cb119103377#about et http://www.idref.fr/026956845/id
# Voir aussi Michel Serres http://www.idref.fr/02713329X/id
# Problèmes : https://github.com/RMLio/rmlmapper-java/issues/159 (RML Mapper ne tient pas compte des colonnes vides de type VARCHAR)
# crm:E21 "Person"
# crm-sup:P20 "same as external identifier (same as)"
# crm:P1 "is identified by (identifies)"
# crm:P98 "brought into life (was born)"
# crm:P100 "was death of (died in)"
 PersonneMapping:
  sources: prelib_personne
  subjects: prelib:personne/$(id)
  predicateobjects:
   - [a, crm:E21]
   - [rdfs:label, $(nom_usuel)]
   - [foaf:name, $(nom_usuel)]
   - [foaf:familyName, $(nom_etat_civil)]
   - [foaf:givenName, $(prenom_etat_civil)]
   - [bnf-onto:FRBNF, $(FRBNF)]
   - [isni-onto:identifierValid, $(ISNI_SPACELESS)]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]   
   - [owl:sameAs, idref:$(idref)/id~iri]
   - [owl:sameAs, databnf:12148/cb$(FRBNF)#about~iri]
   - [owl:sameAs, isni:$(ISNI_SPACELESS)~iri]
   - [owl:sameAs, viaf:$(viaf)~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, idref:$(idref)/id~iri]
   - [crm-sup:P20, databnf:12148/cb$(FRBNF)#about~iri]
   - [crm-sup:P20, isni:$(ISNI_SPACELESS)~iri]
   - [crm-sup:P20, viaf:$(viaf)~iri]
   - [foaf:gender, $(gender), en~lang]
   # Lien avec les ressources anomymes de classe crm:E41   
   - p: crm:P1
     o:
      - mapping: AppellationPersonneMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(personne_id)]       
   - p: crm:P98
     o:
      - mapping: BirthMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]
   - p: crm:P100
     o:
      - mapping: DeathMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]           

 # Avec la proposition de Vincent et Francesco, il n'y a pas de dictinction entre les formes retenues et les formes rejettées
 # blank nodes (ressources anonymes)
 # crm:E41 "Appellation"
 # crm-sup:P21 "has value (is value of)"
 AppellationPersonneMapping:
  sources: prelib_appellationpersonne
  predicateobjects:
  - [a, crm:E41]
  - [crm-sup:P21, $(appellation), $(code_iso_639_3)~lang]

 AppellationRetenuePersonneMapping:
  sources: prelib_appellationpersonne
  subjects: prelib:personne/$(personne_id)
  predicateobjects:
   - [skos:prefLabel, $(appellation), $(code_iso_639_3)~lang]
  condition:
    function: idlab-fn:equal
    parameters:
     - [grel:valueParameter, $(forme)]
     - [grel:valueParameter2, "2"]
   
 AppellationRejetteePersonneMapping:
  sources: prelib_appellationpersonne
  subjects: prelib:personne/$(personne_id)
  predicateobjects:
   - [skos:altLabel, $(appellation), $(code_iso_639_3)~lang]
  condition:
    function: idlab-fn:equal
    parameters:
     - [grel:valueParameter, $(forme)]
     - [grel:valueParameter2, "1"]

 # crm:E69 "Death"
 # crm:P7 "took place at (witnessed)"
 # crm:P4 "has time-span (is time-span of)"
 DeathMapping:
  sources: prelib_personne
  predicateobjects:
   - [a, crm:E69]
   - p: crm:P7
     o:
      - mapping: VilleMapping
        condition:
         function: equal
         parameters:
          - [str1, $(ville_deces_id)]
          - [str2, $(id)]
   - p: crm:P4
     o:
      - mapping: TimeSpanDeathMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]    
 
 # crm:E67 "Birth"
 BirthMapping:
  sources: prelib_personne
  predicateobjects:
   - [a, crm:E67]
   - p: crm:P7
     o:
      - mapping: VilleMapping
        condition:
         function: equal
         parameters:
          - [str1, $(ville_naissance_id)]
          - [str2, $(id)]
   - p: crm:P4
     o:
      - mapping: TimeSpanBirthMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)] 

 # yarrrml-parser ne tient pas compte de l'utilisation de la référence pour forger le datatype
 # créé une issue https://github.com/RMLio/yarrrml-parser/issues/162#issuecomment-1104892337
 # crm:E52 "Time-Span"
 TimeSpanBirthMapping:
  sources: prelib_personne
  predicateobjects:
   - [a, crm:E52]
   - p: crm:P82
     o: $(date_naissance)
     datatype: xsd:gYear
     condition:
      function: equal
      parameters:
       - [str1, $(date_naissance_dtype)]
       - [str2, 'gYear']
   - p: crm:P82
     o: $(date_naissance)
     datatype: xsd:date
     condition:
      function: equal
      parameters:
       - [str1, $(date_naissance_dtype)]
       - [str2, 'date']

 # crm:E52 "Time-Span"  
 TimeSpanDeathMapping:
  sources: prelib_personne
  predicateobjects:
   - [a, crm:E52]
   - p: crm:P82
     o: $(date_deces)
     datatype: xsd:gYear
     condition:
      function: equal
      parameters:
       - [str1, $(date_deces_dtype)]
       - [str2, 'gYear']
   - p: crm:P82
     o: $(date_deces)
     datatype: xsd:date
     condition:
      function: equal
      parameters:
       - [str1, $(date_deces_dtype)]
       - [str2, 'date']

 # crm:E74 "Group"
 # crm-sup:P7 "has group type (is group type of)"
 GroupMapping:
  sources: prelib_collectif
  subjects: prelib:collectif/$(id)
  predicateobjects:
   - [a, crm:E74]
   - [rdfs:label, $(nom), fr~lang]
   - [crm-sup:P7, prelib:type-collectif/$(type_collectif_id)~iri]
   - [isni-onto:identifierValid, $(ISNI_SPACELESS)]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]   
   - [owl:sameAs, idref:$(idref)~iri]
   - [owl:sameAs, databnf:12148/cb$(FRBNF)#about~iri]
   - [owl:sameAs, isni:$(ISNI_SPACELESS)~iri]
   - [owl:sameAs, viaf:$(viaf)~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, idref:$(idref)~iri]
   - [crm-sup:P20, databnf:12148/cb$(FRBNF)#about~iri]
   - [crm-sup:P20, isni:$(ISNI_SPACELESS)~iri]
   - [crm-sup:P20, viaf:$(viaf)~iri]
   # Lien avec les ressources anomymes de classe crm:E41
   - p: crm:P1
     o:
      - mapping: AppellationCollectifMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(collectif_id)]

 # Avec la proposition de Vincent et Francesco, il n'y a pas de dictinction entre les formes retenues et les formes rejettées
 # blank nodes (ressources anonymes)
 # crm:E41 "Appellation"
 AppellationCollectifMapping:
  sources: prelib_appellationcollectif
  predicateobjects:
  - [a, crm:E41]
  - [crm-sup:P21, $(appellation), $(code_iso_639_3)~lang]

 AppellationRetenueCollectifMapping:
  sources: prelib_appellationcollectif
  subjects: prelib:collectif/$(collectif_id)
  predicateobjects:
   - [skos:prefLabel, $(appellation), $(code_iso_639_3)~lang]
  condition:
    function: idlab-fn:equal
    parameters:
     - [grel:valueParameter, $(forme)]
     - [grel:valueParameter2, "2"]
   
 AppellationRejetteeCollectifMapping:
  sources: prelib_appellationcollectif
  subjects: prelib:collectif/$(collectif_id)
  predicateobjects:
   - [skos:altLabel, $(appellation), $(code_iso_639_3)~lang]
  condition:
    function: idlab-fn:equal
    parameters:
     - [grel:valueParameter, $(forme)]
     - [grel:valueParameter2, "1"]

 # crm-sup:C9 "Group Type"
 TypeCollectifMapping:
  sources: prelib_typecollectif
  subjects: prelib:type-collectif/$(id)
  predicateobjects:
   - [a, crm-sup:C9]
   - [rdfs:label, $(nom), fr~lang]

 # sdh-sls:C2 "Attending a School"
 # sdh-sls:P3 "concerned person (attending a school)"
 # sdh-sls:P2 "concerned school (is attended by)"
 EtudesMapping:
  source: prelib_etudes
  subjects: prelib:etudes/$(id)
  predicateobjects:
   - [a, sdh-sls:C2]
   - [sdh-sls:P3, prelib:personne/$(personne_id)~iri]
   - [sdh-sls:P4, prelib:collectif/$(groupe_id)~iri]
   - p: crm:P4
     o: 
      - mapping: TimeSpanEtudesMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]

 # crm:E52 "Time-Span"
 # crm:P82a "begin of the begin"
 # crm:P82b "end of the end"
 TimeSpanEtudesMapping:
  source: prelib_etudes
  predicateobjects:
  - [a, crm:E52]
  - predicates: crm:P82a
    objects:
     value: $(annee_debut_etudes)
     datatype: xsd:gYear
  - predicates: crm:P82b
    objects:
     value: $(annee_fin_etudes)
     datatype: xsd:gYear

 # frbroo:F3 "Manifestation Product Type"
 # crm:P102 "has title (is title of)"
 ManifestationProductTypeMapping:
  sources: prelib_edition
  subjects: prelib:edition/$(id)
  predicateobjects:
   - [a, frbroo:F3]
   - [rdfs:label, $(titre)]
   - [crm:P102, $(titre)]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]
   - [owl:sameAs, sudoc:$(sudoc)~iri]
   - [owl:sameAs, databnf:12148/cb$(FRBNF)#about~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, sudoc:$(sudoc)~iri]
   - [crm-sup:P20, databnf:12148/cb$(FRBNF)#about~iri]
   - [bibo:isbn10, $(isbn_10)]
   - [bibo:isbn13, $(isbn_13)]

 # crm:P14 "carried out by"
 # sdh-int:P3 "created manifestation (was created by)"
 # Fonctionne parce que j'ai considéré qu'une édition n'est lié qu'à 
 # un seul sdh-int:C1 "Expression Publication Event" d'URI 
 # prelib:edition-event/$(edition_id) (soit le même identifiant que l'éditions
 EditeOeuvreMapping:
  sources: prelib_editeoeuvre
  subjects: prelib:edition-event/$(edition_id)
  predicateobjects:
   - p: crm:P14
     o:
      - mapping: GroupMapping
        condition:
         function: equal
         parameters:
          - [str1, $(collectif_id)]
          - [str2, $(id)]
   - p: sdh-int:P3
     o:
      - mapping: ManifestationProductTypeMapping
        condition:
         function: equal
         parameters:
          - [str1, $(edition_id)]
          - [str2, $(id)]

 # sdh-int:C1 "Expression Publication Event"
 # crm:P4 "has time-span (is time-span of)"
 ExpressionPublicationEventMapping:
  sources: prelib_edition
  subjects: prelib:edition-event/$(id)
  predicateobjects:
   - [a, sdh-int:C1]        
   - p: crm:P4
     o: 
      - mapping: TimeSpanExpressionPublicationEventMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]

 # crm:E52 "Time-Span"
 # crm:P82 "at some time within"
 TimeSpanExpressionPublicationEventMapping:
  sources: prelib_edition
  predicateobjects:
   - [a, crm:E52]
   - p: crm:P82
     o: $(annee_publication)
     datatype: xsd:gYear

 # frbroo:F23 "Expression Fragment"
 # frbroo:R15 "has fragment (is fragment of)"
 # crm:P129 "is about (is subject of)"
 EstDedicaceAMapping:
  sources: prelib_estdedicacea
  predicateobjects:
   - [a, crm:F23]
   - [frbroo:R15, prelib:oeuvre/$(oeuvre_id)~iri]
   - [crm:P129, prelib:personne/$(personne_id)~iri]

 EstDedicaceACollectifMapping:
  sources: prelib_estdedicaceacollectif
  predicateobjects:
   - [a, crm:F23]
   - [frbroo:R15, prelib:oeuvre/$(oeuvre_id)~iri]
   - [crm:P129, prelib:collectif/$(collectif_id)~iri]   

 # crmba:B1 "Built Work"
 # sdh:P17 "has location"
 BatimentMapping:
  sources: prelib_batiment
  subjects: prelib:batiment/$(id)
  predicateobjects:
   - [a, crmba:B1]
   - [rdfs:label, $(nom), fr~lang]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
   - [sdh:P17, prelib:ville/$(ville_id)~iri]

 # Le nom des mappings et les subjects suivants étaient mal choisis jusqu'à que je décide de ne pas instancier 
 # prelib_fonctioncollaborerevue en tant que sdh-so:C7, comme suggéré par Vincent. 
 # Autrement dit, il y aurait pu y avoir d'autres mappings d'"Occupation"s que ceux de la table prelib_qualiteparticipecollectif.

 # sdh-so:C7 "Occupation"
 QualiteParticipeCollectifMapping:
  sources: prelib_qualiteparticipecollectif
  subjects: prelib:occupation/$(id)  
  predicateobjects:
   - [a, sdh-so:C7]
   - [rdfs:label, $(nom), fr~lang]

 # sdh-so:C4 "Social Relationship Type"
 QualiteRelationMapping:
  sources: prelib_qualiterelation
  subjects: prelib:qualite-relation/$(id)
  predicateobjects:
   - [a, sdh-so:C4]
   - [rdfs:label, $(nom), fr~lang]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]

# Anciennement des blank nodes (ressources anonymes) mais pour faciliter 
# le déboguage, on utilise finalement des URI.
# sdh-so:C8 "Occupation (Temporal entity)"
# sdh-so:P4 "is occupation of (is about)"
# sdh-so:P5 "is about (is occupation of)"
# sdh-so:P7 "on behalf of (provides occupation)"
# crm:P8 "took place on or within"
# crm:P4 "has time-span (is time-span of)"
 OccupationTemporalEntityMapping:
  sources: prelib_profession
  subjects: prelib:occupation-temporal-entity/$(id)  
  predicateobjects:
   - [a, sdh-so:C8]
   # A voir si on n'écrit pas cette ligne comme pour sdh-so:P7 lié au GroupMapping
   - [sdh-so:P4, prelib:personne/$(personne_id)~iri]
   - [crm:P8, prelib:batiment/$(batiment_id)~iri]
   - p: crm:P4
     o: 
      - mapping: TimeSpanOccupationMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]
   - p: sdh-so:P5
     o:
      - mapping: QualiteParticipeCollectifMapping
        condition:
         function: equal
         parameters:
          - [str1, $(qualite_id)]
          - [str2, $(id)]
   - p: sdh-so:P7
     o:
      - mapping: GroupMapping
        condition:
         function: equal
         parameters:
          - [str1, $(groupe_id)]
          - [str2, $(id)]

# Il faudrait gérer le fait que les date_debut, date_fin ne sont pas toujours saisies
# ou qu'elles sont remplacées par annee_debut et annee_fin
# voir les fonction GREL trouvées par Christine
# - https://docs.openrefine.org/manual/grel
# - https://gitlab.huma-num.fr/portic/porticttl/-/blob/main/writing_rules_yarrrml.md
# - https://github.com/RMLio/yarrrml-parser/blob/development/test/condition-function-on-po/mapping.yarrrml
# - https://fno.io/spec/ (The Function Ontology)
# - http://users.ugent.be/~bjdmeest/function/grel.ttl#
 # crm:E52 "Time-Span"
 # crm:P82a "begin of the begin"
 # crm:P82b "end of the end"
 TimeSpanOccupationMapping:
  sources: prelib_profession
  predicateobjects:
  - [a, crm:E52]
  - predicates: crm:P82a
    objects:
     value: $(date_debut)
     datatype: xsd:date
  - predicates: crm:P82b
    objects:
     value: $(date_fin)
     datatype: xsd:date
  - predicates: crm:P82a
    objects:
     value: $(annee_debut)
     datatype: xsd:gYear
  - predicates: crm:P82b
    objects:
     value: $(annee_fin)
     datatype: xsd:gYear

 # sdh-so:C3 "Social Relationship"
 # sdh-so:P16 "has relationship type (is relationship type of)"
 # sdh-so:P17 "has relationship source (is source in relationship)"
 # shd-so:P18 "has relationship target (is target in relationship)"
 RelationInterpersonnelleMapping:     
  sources: prelib_relationinterpersonnelle
  subjects: prelib:relation-interpersonnelle/$(id)  
  predicateobjects:
   - [a, sdh-so:C3]
   - [sdh-so:P18, prelib:personne/$(personne_id)~iri]
   - [sdh-so:P17, prelib:personne/$(relation_id)~iri]
   - [sdh-so:P16, prelib:qualite-relation/$(qualite_relation_id)~iri]
   - p: crm:P4
     o:
      - mapping: TimeSpanRelationInterpersonnelleMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]

 # crm:E52 "Time-Span"
 # crm:P82a "begin of the begin"
 # crm:P82b "end of the end"
 # Cette version utilise une requête SQL où les dates peuvent avoir pour valeur NULL
 # auquel cas, le mapping ne crée par les triplets concernés (crm:P82a et crm:P82b).
 TimeSpanRelationInterpersonnelleMapping:
  sources: prelib_relationinterpersonnelle
  predicateobjects:
  - [a, crm:E52]
  - predicates: crm:P82a
    objects:
     value: $(date_debut_relation)
     datatype: xsd:date
  - predicates: crm:P82b
    objects:
     value: $(date_fin_relation)
     datatype: xsd:date
  - predicates: crm:P82a
    objects:
     value: $(annee_debut_relation)
     datatype: xsd:gYear
  - predicates: crm:P82b
    objects:
     value: $(annee_fin_relation)
     datatype: xsd:gYear          

 # frbroo:F2 "Expression"
 # crm:E33 "Linguistic Object"
 ExpressionMapping:
  sources: prelib_oeuvre
  subjects: prelib:oeuvre/$(id)
  predicateobjects:
   - [a, frbroo:F2]
   - [a, crm:E33]
   - [rdfs:label, $(titre)]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]
   - [owl:sameAs, databnf:12148/cb$(FRBNF)#about~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, databnf:12148/cb$(FRBNF)#about~iri]
 
 # frbroo:F24 "Publication Expression"
 # frbroo:CLR6i "should be carried by"
 # frbroo:R5 "has component"
 OeuvreEditionMapping:
  sources: prelib_oeuvreedition
  predicateobjects:
   - [a, frbroo:F24]
   - p: frbroo:CLR6i
     o:
      - mapping: ManifestationProductTypeMapping
        condition:
         function: equal
         parameters:
          - [str1, $(edition_id)]
          - [str2, $(id)]
   - p: frbroo:R5
     o:
      - mapping: ExpressionMapping
        condition:
         function: equal
         parameters:
          - [str1, $(oeuvre_id)]
          - [str2, $(id)]    

 # crm:P72 "has language (is language of)"
 OeuvreLangueMapping:
  sources: prelib_oeuvrelangue
  subjects: prelib:oeuvre/$(oeuvre_id)
  predicateobjects:
   - [crm:P72, lexvo:$(code_iso_639_3)~iri]

 # Probleme de l'expression du rôle du createur, nécessiterait de la reification pour utiliser P14.1 in the role of, 
 # propriété de la propriété P14 carried out by (performed).
 # LRMoo (et son prédécesceur FRBRoo) fonctionnent que si on exprime tout ce qui constitue une édition (les illustrations, la préface, le texte...)
 # sous la forme d'un F1 Work, où il n'existe plus d'illustrateur, de préfacier, de scénariste mais des auteurs de l'illustration, de la préface, du scénario... 
 # Ne vaudrait-il pas mieux exprimer ces informations avec les mêmes ontologies que celles utilisées
 # par data.bnf.fr ou data.idref.fr ?
 # - https://cidoc-crm.org/sites/default/files/Roles.pdf
 # - https://www.ontotext.com/blog/graphdb-users-ask-is-rdf-star-best-choice-for-reification/
 # - https://graphdb.ontotext.com/documentation/9.4/free/devhub/rdf-sparql-star.html
 # - http://cidoc-crm.org/cidoc-crm/7.1.1/P14_carried_out_by
 #
 # frbroo:F28 "Expression Creation"
 # frbroo:R17 "created Expression from Expression Creation"
 # crm:P3 "has note"
 # crm:P4 "has time span"
 PersonneExpressionCreationMapping:
  sources: prelib_ecritoeuvre
  predicateobjects:
   - [a, frbroo:F28]
   # La table prelib_ecritoeuvre ne contient pas que des relations entre des oeuvres et des auteurs
   # mais des fonction_id = éditeurs scientifiques, traducteurs, collecteur, illustrateur, préfacier, etc.
   # la colonne date_ecriture dont est dérivée annee devrait plutôt s'appeller date tout court.
   - [crm:P3, $(nom_fonction), fr~lang]
   - [crm:P4, $(annee)]
   - p: frbroo:R17
     o:
      - mapping: ExpressionMapping
        condition:
         function: equal
         parameters:
          - [str1, $(oeuvre_id)]
          - [str2, $(id)]
   - p: crm:P14
     o:
      - mapping: PersonneMapping
        condition:
         function: equal
         parameters:
          - [str1, $(personne_id)]
          - [str2, $(id)]       

 # frbroo:F28 "Expression Creation"
 # frbroo:R17 "created Expression from Expression Creation"
 # crm:P3 "has note"
 # crm:P4 "has time span"
 # crm:P14 "carried out by (performed)"
 CollectifExpressionCreationMapping:
  sources: prelib_collectifecritoeuvre
  predicateobjects:
   - [a, frbroo:F28]
   # Voir remarque ci-dessus au sujet de la table prelib_ecritoeuvre
   - [crm:P3, $(nom_fonction), fr~lang]
   - [crm:P4, $(annee)]
   - p: frbroo:R17
     o:
      - mapping: ExpressionMapping
        condition:
         function: equal
         parameters:
          - [str1, $(oeuvre_id)]
          - [str2, $(id)]
   - p: crm:P14
     o:
      - mapping: GroupMapping
        condition:
         function: equal
         parameters:
          - [str1, $(collectif_id)]
          - [str2, $(id)]

 # crm-sup:C6 "Expression Type"
 TypeOeuvreMapping:
  sources: prelib_typeoeuvre
  subjects: prelib:type-oeuvre/$(id)
  predicateobjects:
   - [a, crm-sup:C6]
   - [rdfs:label, $(intitule), fr~lang]

 # crm-sup:P4 "has expression type (is expression type of)"
 OeuvreTypesMapping:
  sources: prelib_oeuvre_types
  subjects: prelib:oeuvre/$(oeuvre_id)
  predicateobjects:
   - [crm-sup:P4, prelib:type-oeuvre/$(typeoeuvre_id)]

 # Pour bibo:issn, voir https://data.bnf.fr/fr/semanticweb et LOV
 # frbroo:F18 "Serial Work"
 RevueMapping:
  sources: prelib_revue
  subjects: prelib:revue/$(id)
  predicateobjects:
   - [a, frbroo:F18]
   - [crm:P102, $(titre)]
   - [rdfs:label, $(titre)]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]
   - [owl:sameAs, sudoc:$(sudoc)~iri]
   - [owl:sameAs, databnf:12148/cb$(FRBNF)#about~iri]
   - [owl:sameAs, worldcat:$(oclc)~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, sudoc:$(sudoc)~iri]
   - [crm-sup:P20, databnf:12148/cb$(FRBNF)#about~iri]
   - [crm-sup:P20, worldcat:$(oclc)~iri]
   - [bibo:issn, $(issn)]
   - [bibo:eissn, $(issn_numerique)]
   - [bibo:oclcnum, $(oclc)]
 
 # frbroo:F30 "Publication Event"
 # frbroo:R23 "created a realisation of"
 # crm:P14 "carried out by (performed)" 
 PublicationEventMapping:
  sources: prelib_editerevue
  predicateobjects:
   - [a, frbroo:F30]
   - p: frbroo:R23
     o:
      - mapping: RevueMapping
        condition:
         function: equal
         parameters:
          - [str1, $(revue_id)]
          - [str2, $(id)]
   - p: crm:P14
     o:
      - mapping: GroupMapping
        condition:
         function: equal
         parameters:
          - [str1, $(collectif_id)]
          - [str2, $(id)]

 # frbroo:F24 "Publication Expression" = expression de l'intégralité d'un numéro d'une revue 
 # frbroo:R15 "has fragment (is fragment of)"
 # crm:P106 "is composed of (forms part of)"
 # frbroo:CLR6 "should carry (should be carried by)"
 ParaitDansMapping:
  sources: prelib_paraitdans
  subjects: prelib:parait-dans-revue/$(id)
  predicateobjects: 
   - [a, frbroo:F24]
   - [crm:P106, prelib:oeuvre/$(oeuvre_id)~iri]
   - p: frbroo:R15
     o:
      - mapping: ParaitDansNumeroRevueMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]
      - mapping: ParaitDansPageDebutMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]
      - mapping: ParaitDansPageFinMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]
      - mapping: ParaitDansDateParutionMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]          
   - p: frbroo:CLR6
     o:
      - mapping: ParaitDansManifestationProductTypeMapping
        condition:
         function: equal
         parameters:
          - [str1, $(id)]
          - [str2, $(id)]   

 # frbroo:F23 "Expression Fragment"
 # crm:P2 "has type (is type of)"
 # crm:P3 "has note"
 ParaitDansNumeroRevueMapping:
  sources: prelib_paraitdans
  predicateobjects: 
   - [a, frbroo:F23]
   - [crm:P2, "numéro", fr~lang]
   - [crm:P3, $(numero_revue), fr~lang]

 ParaitDansPageDebutMapping:
  sources: prelib_paraitdans
  predicateobjects:
   - [a, frbroo:F23]
   - [crm:P2, "page de début", fr~lang]
   - [crm:P3, $(page_debut), xsd:integer]

 ParaitDansPageFinMapping:
  sources: prelib_paraitdans
  predicateobjects: 
   - [a, frbroo:F23]
   - [crm:P2, "page de fin", fr~lang]
   - [crm:P3, $(page_fin), xsd:integer]
  
 ParaitDansDateParutionMapping:
  sources: prelib_paraitdans
  predicateobjects:
   - [a, frbroo:F23]
   - [crm:P2, "date de parution", fr~lang]
   - p: crm:P3
     o:
      - value: $(date_parution)
        datatype: xsd:gYear
        condition:
         function: equal
         parameters:
          - [str1, $(date_parution_dtype)]
          - [str2, 'gYear']
      - value: $(date_parution)
        datatype: xsd:date
        condition:
         function: equal
         parameters:
          - [str1, $(date_parution_dtype)]
          - [str2, 'date']
 
 # frbroo:F3 "Manifestation Product Type"
 # sdh-int:P20 "has issue (is issue of)"
 # Ressource nécessaire pour lier la frbroo:F24 "Publication Expression"
 # de ParaitDansMapping à la revue (frbroo:F18 "Serial Work")
 ParaitDansManifestationProductTypeMapping:
  sources: prelib_paraitdans
  predicateobjects: 
   - [a, frbroo:F3]
   - [sdh-int:P20, prelib:revue/$(revue_id)~iri]
 
 # sdh:C13 "Geographical Place"
 VilleMapping:
  sources: prelib_ville
  subjects: prelib:ville/$(id)
  predicateobjects:
   - [a, sdh:C13]
   - [rdfs:label, $(nom), fr~lang]
   - [owl:sameAs, wd:$(wikidata)~iri]
   - [owl:sameAs, factgrid:$(factgrid)~iri]
   - [crm-sup:P20, wd:$(wikidata)~iri]
   - [crm-sup:P20, factgrid:$(factgrid)~iri]
